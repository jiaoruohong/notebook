\subsection{\href{https://leetcode-cn.com/}{Leetcode 1}}\label{app:problemlist:leetcode:1}

\textbf{Problem Description:}\par

\textbf{两数之和}\par

给定一个整数数组 $ nums $ 和一个目标值 $ target $ ，
请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\par

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
给定 nums = [2, 7, 11, 15], target = 9
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:1}):\par

没有说明输入数字一定是正整数，不能先排序后提取小于 $ target $ 的数进行求解。\par

懒一点， $ n^{2} $ 循环。勤快一点用红黑树、堆进行存储然后查询 $ nlogn $ 。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 2}}\label{app:problemlist:leetcode:2}

\textbf{Problem Description:}\par

\textbf{两数相加}\par

给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。\par

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\par

您可以假设除了数字0之外，这两个数都不会以0开头。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：7 -> 0 -> 8
原因：342 + 465 = 807
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:2}):\par

大数加法，注意指针/引用转换。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 3}}\label{app:problemlist:leetcode:3}

\textbf{Problem Description:}\par

\textbf{无重复字符的最长子串}\par

给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: "abcabcbb"

输入: "bbbbb"

输入: "pwwkew"
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:3}):\par

标记l和r，遍历一遍，更新答案。时间方面，能用数组不用STL。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 6}}\label{app:problemlist:leetcode:6}

\textbf{Problem Description:}\par

\textbf{Z字形变换}\par

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\par

比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：\par

\begin{lstlisting}[language=bash]
L   C   I   R
E T O E S I I G
E   D   H   N
\end{lstlisting}

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: s = "LEETCODEISHIRING", numRows = 3
  
输入: s = "LEETCODEISHIRING", numRows = 4
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: "LCIRETOESIIGEDHN"

输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:6}):\par

计算第一行字符id，前后搜查。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 7}}\label{app:problemlist:leetcode:7}

\textbf{Problem Description:}\par

\textbf{整数反转}\par

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\par

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\par

假设环境不允许存储 64 位整数（有符号或无符号）。\par



\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：x = 123

输入：x = -123

输入：x = 120

输入：x = 0
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：321

输出：-321

输出：21

输出：0
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:7}):\par

对10取模，倒序重构。（刚开始写的时候没有用INT\_MAX，INT\_MIN，用的字符串去判断，很繁。）\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 8}}\label{app:problemlist:leetcode:8}

\textbf{Problem Description:}\par

\textbf{字符串转换整数 (atoi)}\par

请你来实现一个 myAtoi(string s) 函数，
使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。\par

函数 myAtoi(string s) 的算法如下：\par

读入字符串并丢弃无用的前导空格检查下一个字符
（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 
确定最终结果是负数还是正数。 
如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。
字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。
如果没有读入数字，则整数为 0 。
必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，
需要截断这个整数，使其保持在这个范围内。
具体来说，小于 −231 的整数应该被固定为 −231 ，
大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。\par

注意：\par

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\par



\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：s = "42"

输入：s = "   -42"

输入：s = "4193 with words"

输入：s = "words and 987"

输入：s = "-91283472332"
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。

输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。

输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。

输出：0
解释：
第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。

输出：-2147483648
解释：
第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）
          ^
第 3 步："-91283472332"（读入 "91283472332"）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:8}):\par

用INT\_MAX，INT\_MIN检测数值边界。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 9}}\label{app:problemlist:leetcode:9}

\textbf{Problem Description:}\par

\textbf{回文数}\par

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\par

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：x = 121

输入：x = -121

输入：x = 10

输入：x = -101
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：true

输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。

输出：false
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:9}):\par

用INT\_MAX，INT\_MIN检测数值边界。翻转数字后和原数值比较。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 11}}\label{app:problemlist:leetcode:11}

\textbf{Problem Description:}\par

\textbf{盛最多水的容器}\par

给你n个非负整数 $ a1, a2, \cdots, an $ ，每个数代表坐标中的一个点 $ (i, ai) $ 。
在坐标内画n条垂直线，垂直线i的两个端点分别为 $ (i, ai) $ 和 $ (i, 0) $。
找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。\par

说明：你不能倾斜容器，且 n 的值至少为 2。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：[1,8,6,2,5,4,8,3,7]
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：49
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:11}):\par

两边到中间遍历一遍，贪心选择更高的边维持原状。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 14}}\label{app:problemlist:leetcode:14}

\textbf{Problem Description:}\par

\textbf{最长公共前缀}\par

编写一个函数来查找字符串数组中的最长公共前缀。\par

如果不存在公共前缀，返回空字符串""。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：strs = ["flower","flow","flight"]

输入：strs = ["dog","racecar","car"]
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出："fl"

输出：""
解释：输入不存在公共前缀。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:14}):\par

第一种方法是快排之后对比首位字符串得出结果。\par

考虑字符串快排复杂度涉及字符串间的比较，java代码运行速度较慢，因此第二种方法不用排序，直接以第一个字符串为基础，在后续字符串中对比，若不是前缀，则长度减少，直至匹配。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 15}}\label{app:problemlist:leetcode:15}

\textbf{Problem Description:}\par

\textbf{三数之和}\par

给你一个包含n个整数的数组nums，判断nums中是否存在三个元素 $ a, b, c $ ，
使得 $ a + b + c = 0 $ ？
请你找出所有满足条件且不重复的三元组。\par

注意：答案中不可以包含重复的三元组。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:15}):\par

不要依赖STL，不是所有题目都需要离散化处理。对于一般的链表问题，去重遍历就可以达到离散化的效果。\par

先排序，指定一个数值的基础上再挑选符合条件的另外两个数值。贪心匹配两个数值的大小。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 16}}\label{app:problemlist:leetcode:16}

\textbf{Problem Description:}\par

\textbf{最接近的三数之和}\par

给定一个包括n个整数的数组nums和 一个目标值target。
找出nums中的三个整数，使得它们的和与target最接近。
返回这三个数的和。假定每组输入只存在唯一答案。\par

提示：\par

$$ 3 <= nums.length <= 10^{3} $$
$$ -10^{3} <= nums[i] <= 10^{3} $$
$$ -10^{4} <= target <= 10^{4} $$


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：nums = [-1,2,1,-4], target = 1
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:16}):\par

不要依赖STL，不是所有题目都需要离散化处理。对于一般的链表问题，去重遍历就可以达到离散化的效果。\par

先排序，指定一个数值的基础上再挑选符合条件的另外两个数值。贪心匹配两个数值的大小。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 19}}\label{app:problemlist:leetcode:19}

\textbf{Problem Description:}\par

\textbf{Problem Description:}\par

\textbf{删除链表的倒数第N个节点}\par

给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
给定一个链表: 1->2->3->4->5, 和 n = 2.
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
当删除了倒数第二个节点后，链表变为 1->2->3->5.
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:19}):\par

递归记录个数。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 25}}\label{app:problemlist:leetcode:25}

\textbf{Problem Description:}\par

\textbf{Problem Description:}\par

\textbf{K 个一组翻转链表}\par

给你一个链表，每k个节点一组进行翻转，请你返回翻转后的链表。\par

k是一个正整数，它的值小于或等于链表的长度。\par

如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺序。\par

说明：\par

你的算法只能使用常数的额外空间。\par

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
给你这个链表：1->2->3->4->5
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:25}):\par

标记子链表首尾，化简为链表反转问题，递归解决。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 26}}\label{app:problemlist:leetcode:26}

\textbf{Problem Description:}\par

\textbf{删除排序数组中的重复项}\par

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\par

不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 $ O(1) $ 额外空间的条件下完成。\par

说明:\par

为什么返回数值是整数，但输出的答案是数组呢?\par

请注意，输入数组是以引用方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\par

你可以想象内部操作如下:\par

\begin{lstlisting}[language=bash]
输入：nums = [-1,2,1,-4], target = 1

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
\end{lstlisting}


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
给定数组 nums = [1,1,2], 

给定 nums = [0,0,1,1,1,2,2,3,3,4],
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:26}):\par

原始数组已经排过序了。注意当数据量大的时候，判断条件越少越好。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 42}}\label{app:problemlist:leetcode:42}

\textbf{Problem Description:}\par

\textbf{接雨水}\par

给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\par

上面是由数组 $ [0,1,0,2,1,0,1,3,2,1,2,1] $ 表示的高度图，
在这种情况下，可以接6个单位的雨水（蓝色部分表示雨水）。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: 6
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:42}):\par

左右打表记录最大值，查询之后得出结果。\par

老问题，注意当数据量大的时候，判断条件越少越好。
以及，多用C++11的新初始化特性可以减少时间开销。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 43}}\label{app:problemlist:leetcode:43}

\textbf{Problem Description:}\par

\textbf{字符串相乘}\par

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\par

说明：\par

1. num1 和 num2 的长度小于110。\par
2. num1 和 num2 只包含数字 0-9。\par
3. num1 和 num2 均不以零开头，除非是数字 0 本身。\par
4. 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。\par



\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: num1 = "2", num2 = "3"

输入: num1 = "123", num2 = "456"
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: "6"

输出: "56088"
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:43}):\par

大数相乘。两数相乘的结果位数不超过两数位数之和。根据乘数位数，可以直接推断出该数值在结果数值中的未知。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 56}}\label{app:problemlist:leetcode:56}

\textbf{Problem Description:}\par

\textbf{合并区间}\par

给出一个区间的集合，请合并所有重叠的区间。。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]

输入: intervals = [[1,4],[4,5]]
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:56}):\par

自定义排序之后合并。需要注意对是C++快排默认比较顺序是挨个从小到大，如果可以使用原始比较函数就不要自己重新写，还是用初始的更快。\par

注意java的自定义比较函数。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 61}}\label{app:problemlist:leetcode:61}

\textbf{Problem Description:}\par

\textbf{旋转链表}\par

给定一个链表，旋转链表，将链表每个节点向右移动k个位置，其中k是非负数。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: 1->2->3->4->5->NULL, k = 2

输入: 0->1->2->NULL, k = 4
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL

输出: 2->0->1->NULL
解释:
向右旋转 1 步: 2->0->1->NULL
向右旋转 2 步: 1->2->0->NULL
向右旋转 3 步: 0->1->2->NULL
向右旋转 4 步: 2->0->1->NULL
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:61}):\par

对k取模得到mk，之后更改倒数第mk个node开始第子链表顺序到首位。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 121}}\label{app:problemlist:leetcode:121}

\textbf{Problem Description:}\par

\textbf{买卖股票的最佳时机}\par

给定一个数组，它的第i个元素是一支给定股票第i天的价格。\par

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\par

注意：你不能在买入股票前卖出股票。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: [7,1,5,3,6,4]

输入: [7,6,4,3,1]
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:121}):\par

从后向前打表记录最大值，查询之后得出结果。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 138}}\label{app:problemlist:leetcode:138}

\textbf{Problem Description:}\par

\textbf{复制带随机指针的链表}\par

给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。\par

要求返回这个链表的深拷贝。 \par

我们用一个由n个节点组成的链表来表示输入/输出中的链表。每个节点用一个 $ [val, random_index] $ 表示：\par

$ val $：一个表示 Node.val 的整数。\par
$ random_index $：随机指针指向的节点索引（范围从0到n-1）；如果不指向任何节点，则为null 。\par

$ -10000 <= Node.val <= 10000 $\par

$ Node.random $ 为空（null）或指向链表中的节点。\par

节点数目不超过1000。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]

输入：head = [[1,1],[2,1]]
输入：head = [[3,null],[3,0],[3,null]]
输入：head = []
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[1,1],[2,1]]
输出：[[3,null],[3,0],[3,null]]
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:138}):\par

map存储节点pair。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 141}}\label{app:problemlist:leetcode:141}

\textbf{Problem Description:}\par

\textbf{环形链表}\par

给定一个链表，判断链表中是否有环。\par

为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。
如果pos是-1，则在该链表中没有环。\par

进阶：\par

你能用 $ O(1) $ （即，常量）内存解决此问题吗？\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：head = [3,2,0,-4], pos = 1

输入：head = [1,2], pos = 0

输入：head = [1], pos = -1
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

输出：false
解释：链表中没有环。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:141}):\par

快慢指针循环跑圈相遇查重。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 172}}\label{app:problemlist:leetcode:172}

\textbf{Problem Description:}\par

\textbf{阶乘后的零}\par

给定一个整数 n，返回 n! 结果尾数中零的数量。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: 3

输入: 5
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: 0
解释: 3! = 6, 尾数中没有零。

输出: 1
解释: 5! = 120, 尾数中有 1 个零.
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:172}):\par

产生尾数0的原因是阶乘结果含有因子10，因子10的个数等于因子5的个数（因子2的个数必然大于因子5的个数）。因此答案等于因子5的个数。\par

考虑 $n/5$ （向下取整），其结果是数 $k<=n$ 中含有因子5的个数。推广，$n/5^{m}$ 就是计算 $k<=n$ 中含有因子 $5^{m}$ 的个数。\par

因此连续对n向下取整的除以5就是逐步计算含有 $5^{m}$ 因子的数的个数，也就是该因子的个数。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 202}}\label{app:problemlist:leetcode:202}

\textbf{Problem Description:}\par

\textbf{快乐数}\par

编写一个算法来判断一个数n是不是快乐数。\par

快乐数定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，
然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。
如果可以变为1，那么这个数就是快乐数。\par

如果 n 是快乐数就返回 True ；不是，则返回 False 。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：19
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:202}):\par

快慢指针循环跑圈相遇查重。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 206}}\label{app:problemlist:leetcode:206}

\textbf{Problem Description:}\par

\textbf{反转链表}\par

反转一个单链表。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: 1->2->3->4->5->NULL
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: 5->4->3->2->1->NULL
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:206}):\par

递归或先找到首尾节点之后while循环更新next。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 209}}\label{app:problemlist:leetcode:209}

\textbf{Problem Description:}\par

\textbf{长度最小的子数组}\par

给定一个含有n个正整数的数组和一个正整数s，
找出该数组中满足其和 $ >= s $ 的长度最小的连续子数组，并返回其长度。
如果不存在符合条件的子数组，返回 0。\par

进阶：\par

如果你已经完成了 $ O(n) $ 时间复杂度的解法, 请尝试 $ O(n log n) $ 时间复杂度的解法。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：s = 7, nums = [2,3,1,2,4,3]
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:209}):\par

遍历一遍，滑动窗口更新数值。\par

或者前缀和，二分搜索数值。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 258}}\label{app:problemlist:leetcode:258}

\textbf{Problem Description:}\par

\textbf{各位相加}\par

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。\par

进阶:\par
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入: 38

\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出: 2
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:258}):\par

产生尾数0的原因是阶乘结果含有因子10，因子10的个数等于因子5的个数（因子2的个数必然大于因子5的个数）。因此答案等于因子5的个数。\par

考虑 $n/5$ （向下取整），其结果是数 $k<=n$ 中含有因子5的个数。推广，$n/5^{m}$ 就是计算 $k<=n$ 中含有因子 $5^{m}$ 的个数。\par

因此连续对n向下取整的除以5就是逐步计算含有 $5^{m}$ 因子的数的个数，也就是该因子的个数。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 387}}\label{app:problemlist:leetcode:387}

\textbf{Problem Description:}\par

\textbf{字符串中的第一个唯一字符}\par

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 $ -1 $ 。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
leetcode
loveleetcode
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
0
2
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:387}):\par

找到字符出现的首位和末位进行判断，然后取最早出现的。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 763}}\label{app:problemlist:leetcode:763}

\textbf{Problem Description:}\par

\textbf{划分字母区间}\par

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：S = "ababcbacadefegdehijhklij"
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:763}):\par

相比于合并区间，该题可以只用每个字母的末尾位置即可。\par



\subsection{\href{https://leetcode-cn.com/}{Leetcode 876}}\label{app:problemlist:leetcode:876}

\textbf{Problem Description:}\par

\textbf{链表的中间结点}\par

给定一个带有头结点head的非空单链表，返回链表的中间结点。\par

如果有两个中间结点，则返回第二个中间结点。\par


\textbf{Sample:}\par

input:\par

\begin{lstlisting}[language=bash]
输入：[1,2,3,4,5]

输入：[1,2,3,4,5,6]
\end{lstlisting}

otput:\par

\begin{lstlisting}[language=bash]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.

输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
\end{lstlisting}

\textbf{Solution }(Codes at~\ref{app:codelist:leetcode:876}):\par

快慢指针计数。\par



